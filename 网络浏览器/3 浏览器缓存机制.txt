通常将浏览器分为强缓存和协商缓存：

强缓存：不会向服务器发送请求，直接从缓存中读取资源。
强缓存两种方式：
1  Expires:缓存过期时间，用来指定资源到期时间，Expires是Web服务器响应消息头字段，
在响应http请求时告诉浏览器在过期时间前浏览器可以直接从浏览器缓存取数据，而无需再次请求。
2  Cache-Control：no-Cache:客户端缓存内容，是否使用缓存则需要经过协商缓存来验证决定。
                  表示不使用 Cache-Control的缓存控制方式做前置验证， 而是使用 Etag 或者Last-Modified字段来控制缓存
                  public：所有内容都将被缓存（客户端和代理服务器都可缓存)
                  private：所有内容只有客户端可以缓存   
                  no-store：所有内容都不会被缓存，即不使用强制缓存，也不使用协商缓存
                  max-age：max-age=xxx (xxx is numeric)表示缓存内容将在xxx秒后失效
max-age的优先级高于Expires,强缓存判断是否缓存的依据来自于是否超出某个时间或者某个时间段,而不关心服务器端文件是否已经更新，
这可能会导致加载文件不是服务器端最新的内容，那我们如何获知服务器端内容是否已经发生了更新呢？此时我们需要用到协商缓存策略。
强缓存优先级高于协商缓存


协商缓存：
协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存,主要有以下两种情况：
协商缓存生效，返回304和Not Modified，协商缓存失效，返回200和请求结果
1.Last-Modified和If-Modified-Since
但是 Last-Modified 存在一些弊端：
如果本地打开缓存文件，即使没有对文件进行修改，但还是会造成 Last-Modified 被修改，服务端不能命中缓存导致发送相同的资源
因为 Last-Modified 只能以秒计时，如果在不可感知的时间内修改完成文件，那么服务端会认为资源还是命中了，不会返回正确的资源
既然根据文件修改时间来决定是否缓存尚有不足，能否可以直接根据文件内容是否修改来决定缓存策略
2.ETag和If-None-Match
Etag是服务器响应请求时，返回当前资源文件的一个唯一标识(由服务器生成)，只要资源有变化，Etag就会重新生成

首先在精确度上，Etag要优于Last-Modified。
第一Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，
但是Etag每次都会改变确保了精度；如果是负载均衡的服务器，各个服务器生成的Last-Modified也有可能不一致。
第二在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
第三在优先级上，服务器校验优先考虑Etag

强制缓存优先于协商缓存进行，若强制缓存(Expires和Cache-Control)生效则直接使用缓存，
若不生效则进行协商缓存(Last-Modified / If-Modified-Since和Etag / If-None-Match)，
协商缓存由服务器决定是否使用缓存，若协商缓存失效，那么代表该请求的缓存失效，返回200，
重新返回资源和缓存标识，再存入浏览器缓存中；生效则返回304，继续使用缓存。


缓存改进：
http缓存是浏览器端缓存，cdn是服务器端缓存
CDN缓存:
和Http类似，客户端请求数据时，先从本地缓存查找，如果被请求数据没有过期，拿过来用，如果过期，就向CDN边缘节点发起请求。
CDN便会检测被请求的数据是否过期，如果没有过期，就返回数据给客户端